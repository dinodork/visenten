
%{
#include <iostream>
#include <string>
#include <map>

#include "parse_tree.hpp"

using namespace std;
using namespace parse_tree;

//-- Lexer prototype required by bison, aka getNextToken()
int yylex();
int yyerror (const char *p) { cerr << p << endl; return 1; }

%}

%define parse.error detailed

%union {
  parse_tree::Node* node;
  char sym;
  int val;
  std::string* word;
};

/* SQL Keywords */
%token <sym> DEALLOCATE PARAMETERS INTERSECT TEMPORARY TIMESTAMP
DISTINCT NVARCHAR RESTRICT TRUNCATE ANALYZE BETWEEN
CASCADE COLUMNS CONTROL DEFAULT EXECUTE EXPLAIN
INTEGER NATURAL PREPARE PRIMARY SCHEMAS CHARACTER_VARYING REAL DECIMAL SMALLINT BIGINT
SPATIAL VARCHAR VIRTUAL DESCRIBE BEFORE COLUMN CREATE DELETE DIRECT
DOUBLE ESCAPE EXCEPT EXISTS EXTRACT CAST FORMAT GLOBAL HAVING IMPORT
INSERT ISNULL OFFSET RENAME SCHEMA SELECT SORTED
TABLES UNIQUE UNLOAD UPDATE VALUES AFTER ALTER CROSS
DELTA FLOAT GROUP INDEX INNER LIMIT LOCAL MERGE MINUS ORDER OVER
OUTER RIGHT TABLE UNION USING WHERE CALL CASE CHAR COPY DATE DATETIME
DESC DROP ELSE FILE_SYM FROM FULL HASH HINT INTO JOIN
LEFT LIKE LOAD LONG NULL_SYM PARTITION PLAN SHOW TEXT THEN TIME
VIEW WHEN WITH ADD ALL AND ASC END FOR INT KEY
NOT OFF SET TOP AS BY IF IN IS OF ON OR TO NO
ARRAY CONCAT ILIKE SECOND MINUTE HOUR DAY MONTH YEAR
SECONDS MINUTES HOURS DAYS MONTHS YEARS INTERVAL
TRUE FALSE BOOLEAN
TRANSACTION BEGIN_SYM COMMIT ROLLBACK
NOWAIT SKIP LOCKED SHARE
RANGE ROWS GROUPS UNBOUNDED FOLLOWING PRECEDING CURRENT_ROW

%token <val> NUM STRING
%token <sym> ',' '(' ')' ';' '*' OPA STOP
%token <word> IDENT
%type <word> identifier
%type <val> statement
%type <node>  drop_table_statement table_definition table_element column_definition query_expression
  select_statement data_change_statement insert_statement query_expression_parens subquery
  query_expression_with_trailing_into table_element_list query_expression_body
  query_term query_term_parens query_primary select_list select_sublist table_reference table_factor
  table_name table_name_parens joined_table table_reference_list
  table_reference_list_parens from_clause opt_from_clause join_specification
  expr term order_clause opt_order_clause limit_clause opt_limit_clause
  alias_clause opt_alias_clause column_name data_type row_value_expr row_value_expr_list expr_list
  row_value_constructor literal

%left SUBQUERY_AS_EXPR
%left '(' ')'

%left EMPTY_FROM_CLAUSE
%right INTO

%precedence EMPTY_JOIN_CONDITION
%precedence JOIN ON USING RIGHT LEFT CROSS INNER

%expect 0

%%


start:
    statement_list YYEOF
  | statement_list ';'
  | YYEOF

statement_list:
    statement
  | statement_list ';' statement

statement:
    table_definition              { print($1); cout << endl; }
  | select_statement              { print($1); cout << endl; }
  | data_change_statement         { print($1); cout << endl; }
  | drop_table_statement          { print($1); cout << endl; }

drop_table_statement:
    DROP TABLE identifier { $$ = make_node(DropTable, *$3); }

query_expression:
    query_expression_body opt_order_clause opt_limit_clause {
      $$= make_node(QueryExpression, $1, $2, $3);
    }
  | with_clause query_expression_body opt_order_clause opt_limit_clause {
      $$= make_node(QueryExpression, $2, $3, $4);
    }
  | with_clause query_expression_parens {
    $$= $2;
    }

// opt_with_clause:
// | with_clause

with_clause:
    WITH identifier AS query_expression_parens

query_expression_body:
    query_term                       { $$ = make_node(QueryExpressionBodyTerm, $1); }
  // | with_clause query_term           { $$ = make_node(QueryExpressionBodyTerm, $2); }
  // | with_clause query_term_parens    { $$ = make_node(QueryExpressionBodyTerm, $2); }
  | query_expression_body   UNION query_term        { $$= make_node(Union, $1, $3); }
  | query_expression_parens UNION query_term        { $$= make_node(Union, $1, $3); }
  | query_expression_body   UNION query_term_parens { $$= make_node(Union, $1, $3); }
  | query_expression_parens UNION query_term_parens { $$= make_node(Union, $1, $3); }

query_expression_parens:
    '(' query_expression_parens ')' { $$ = $2; }
  | '(' query_expression ')'        { $$ = $2; }

query_term_parens:
    '(' query_term_parens ')' { $$ = $2; }
  | '(' query_term ')'        { $$ = $2; }

query_term:
    query_primary

query_primary:
    SELECT select_list opt_from_clause
    { $$ = make_node(QuerySpecification, $2, $3); }
  | SELECT select_list into opt_from_clause
    { $$ = make_node(QuerySpecification, $2, $4); }

select_list:
    '*' { make_node(Star); }
  | select_sublist

select_sublist:
    expr
    {
      $$ = make_node(SelectList, $1);
    }
  | select_sublist ',' expr
    {
      $1->push_back(*$3);
    }

select_statement:
    query_expression
  | query_expression_with_trailing_into
  | query_expression_parens

query_expression_with_trailing_into:
    '(' query_expression_with_trailing_into ')' { $$ = $2; }
| query_expression into

into:
    INTO identifier

opt_from_clause:
    /*  empty */ %prec EMPTY_FROM_CLAUSE { $$ = NULL; }
  | from_clause

from_clause:
    FROM table_reference_list { $$ = make_node(FromClause, $2); }

table_reference_list:
    table_reference { $$ = make_node(TableReferenceList, $1); }
  | table_reference_list ',' table_reference { $1->push_back(*$3); }

table_reference:
    table_factor { $$= $1; }
  | joined_table { $$= $1; }

joined_table:
    table_reference join table_reference %prec EMPTY_JOIN_CONDITION
    { $$ = make_node(JoinedTable, $1, $3); }
  | table_reference join table_reference join_specification
    { $$ = make_node(JoinedTable, $1, $3, $4); }

join_specification:
    ON NUM { $$= make_node(On, $2); }
  | USING '(' NUM ')' { $$= NULL; }

join:
    CROSS JOIN
  | INNER JOIN
  | outer_join_type opt_outer JOIN
  | JOIN

outer_join_type:
    LEFT
  | RIGHT

opt_outer:
    // empty
  | OUTER

table_factor:
    table_name opt_alias_clause
  | table_name_parens
  | query_expression_parens opt_alias_clause
    {
      $$ = make_node(DerivedTable, $1, $2);
    }
  | table_reference_list_parens
  | '(' joined_table ')' { $$ = $2; }

table_reference_list_parens:
    '(' table_reference_list_parens ')' { $$ = $2; }
  | '(' table_reference_list ',' table_reference ')'
    {
      $2->push_back(*$4); $$ = $2;
    }

opt_alias_clause:
    /*  empty */ { $$ = NULL; }
  | opt_as alias_clause { $$ = $2; }

opt_as:
    /*  empty */
  | AS

alias_clause:
    identifier { $$ = make_node(AliasClause, "kuken"); }

table_name_parens:
    '(' table_name_parens ')' { $$ = $2; }
  | '(' table_name opt_alias_clause ')' { $$ = $2; }

expr:
    expr '=' term { $$ = make_node(Binop, $1, $3); }
  | term

term:
    literal
  | '(' expr ')' { $$ = $2; }
  | subquery { $$ = make_node(SubqueryExpression, $1); }

literal:
    NUM { $$ = make_node(Num, $1); }
  | STRING { $$ = make_node(Num, $1); }

subquery:
    query_expression_parens %prec SUBQUERY_AS_EXPR

opt_order_clause:
    /* empty */ { $$= NULL; }
  | order_clause

order_clause:
    ORDER BY identifier { $$= make_node(Order); }

opt_limit_clause:
/* empty */ { $$= NULL; }
  | limit_clause

limit_clause:
    LIMIT NUM { $$= make_node(Limit); }

table_definition:
    CREATE TABLE table_name '(' table_element_list ')'
    {
      $$ = make_node(TableDefinition, $3, $5);
    }

table_name:
    identifier { $$ = make_node(TableName, *$1); }

table_element_list:
    table_element { $$ = make_node(TableElementList, $1); }
  | table_element_list ',' table_element { $1->push_back(*$3); }

table_element:
    column_definition

column_definition:
    column_name data_type { $$ = make_node(ColumnDefinition, $1, $2); }

column_name:
    identifier { $$ = make_node(ColumnName, *$1); }

data_type:
    identifier { $$ = make_node(DataType, *$1); }

identifier:
    IDENT { $$ = $1; }

data_change_statement:
    insert_statement

insert_statement:
    INSERT INTO table_name VALUES row_value_expr_list { $$ = make_node(InsertStatement, $3, $5); }

row_value_expr_list:
    row_value_expr { $$ = make_node(RowValueExpr, $1); }
  | row_value_expr_list ',' row_value_expr { $1->push_back(*$3); }

row_value_expr:
    row_value_constructor

row_value_constructor:
    '(' expr_list ')' { $$ = $2; }

expr_list:
    expr { $$ = make_node(ExprList, $1); };
  | expr_list ',' expr { $1->push_back(*$3); }



%%

int main()
{
  return yyparse();
}
